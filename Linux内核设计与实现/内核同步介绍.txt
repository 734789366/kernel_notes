  1. 共享资源之所以要防止并发访问，是因为如果多个执行线程同时访问和操作数据，就有可能发生各线程之间相互覆盖共享数据的情况，造成被访问数据处于不一致状态。用户空间之所以需要同步，是因为用户空间应用程序会被调度程序抢占和重新调度。
  内核中可能造成并发执行的原因有：
      a. 中断，随时可能发生并打断当前执行的代码；
      b. 软中断和tasklet，内核能在任何时候唤醒或调度软中断和tasklet，打断当前正在执行的代码；
      c. 内核抢占，具有抢占性的内核能够打断另一个正在执行的任务；
      d. 睡眠及用户空间的同步，正在执行的进程可能会睡眠，而另一个调度的进程可能访问共享资源；
      e. 对称多处理器，两个或多个处理器可以同时执行代码，代码中会访问共享资源；
  
  2. 死锁产生需要一定的条件，每个线程都在等待其他线程占用的资源，结果谁都无法释放，所以相互死锁，包括自死锁和互死锁。避免死锁的一些策略：
      a. 如果多个锁被嵌套使用，那么其他函数在使用的时候要按照相同的顺序加锁；
      b. 防止饥饿发生，避免代码无法结束的现象，可引入超时机制；
      c. 不重复请求同一个锁；
      d. 代码设计逻辑力求简单，越复杂的加锁方案越容易产生死锁。
  
  3. 锁的争用是指当一个锁被获取时，其他线程试图获得该锁。一个处于高度争用状态的锁会降低系统的性能。加锁粒度用来描述加锁保护的数据规模，一个粗锁保护大块数据，一个细的锁保护小块数据。当锁争用严重时，加锁太粗会降低扩展性；而锁争用不明显时，加锁太细又会加大系统开销，带来浪费。
  一般在设计初期的时候，使用大粒度的锁以力求简单，当再需要进一步优化时，再使用细粒度的锁。一般在SMP机器上，锁的粒度稍细些，在UP机器上，锁的粒度稍粗些。
  
  4. 内核同步方法包括原子操作，自旋锁，信号量等：
      a. 原子操作可以保证指令以原子的方式执行，执行过程中不被打断，包括原子整数操作和原子位操作。原子性保证一条指令在执行过程中不被打断，而顺序性保证多条指令的执行顺不被搞乱；
      b. 自旋锁是内核中最常见的锁，是一种在短期内进行的轻量级加锁机制，最多只能被一个可执行线程持有。一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋，这会浪费处理器时间，因此自旋锁不应被长时间持有。
	  自旋锁在持有期间不能睡眠，不能被抢占，不能递归调用自旋锁，否则都可能出现死锁；
      c. 读写锁明确的划分读/写操作，多个任务可以并发地持有读锁，但是同时只能有一个进程持有写锁，并且此时没有读锁被持有。读锁可以递归的获取，而写锁不能。读写锁照顾读锁比照顾写锁多一点。
      d. 信号量是一种睡眠锁，如果一个任务试图获得一个不可用的信号量，信号量会将其推入一个等待队列，让其睡眠，而当信号量被释放后，再唤醒处于等待队列中的任务。
	  当加锁时间不长，并且不会睡眠时，利用自旋锁最佳，如果加锁时间很长，并且代码在持有自旋锁时可能睡眠，则使用信号量。因为占用信号量时可能会睡眠，因此只能在进程上下文获取信号量，不能再中断上下文。
	  二值信号量或者互斥信号量是信号量的衍生版，只有0,1两个值，只能被一个进程持有，通过down()和up()来进行使用；
      e. 读写信号量是区分读写访问的信号量，类似读写自旋锁，读写信号量支持并发读，但是同时只能有一个写者存在。所有的读写信号量都是互斥信号量，所以其引用计数器为1。类似读写自旋锁，除非能够明确区分出读者和写者，否则不要使用读写信号量；
      f. 互斥体mutex时一种实现互斥的特定睡眠锁，类似使用计数器为1的信号量，但是使用场景更为严格。任何时候只能有一个任务持有互斥体，加锁者负责解锁，不允许递归使用，不允许在中断和下半部中使用等。当在信号量和互斥体之间选择时，优先使用mutex；
      g. 完成量completion是用于实现内核通知的一个简单方法，一个任务通过完成量通知另一个任务发生了某个特定的事件，以实现同步；
      h. 顺序锁依靠序列计数器实现读写共享数据，当写入数据时，会先获得锁，并且增加引用计数器。而在读取数据的前后，都会获得引用计数器，如果前后不一致，则说明在读取操作期间，数据被修改过，需要重新读取。
	  顺序锁对写者更有利，因为读者并不会影响写锁，当希望写者优先，而又有很多读者时，使用顺序锁做好，例如当读取系统jiffies时；
      i. 内核具有抢占性，意味着内核中的进程在任何时刻都有可能停下来，以便执行另一个更高优先级的任务，而这有可能造成竞争。自旋锁可以作为非抢占区的标记，但是在有些情况下，并不需要自旋锁也行，例如per_cpu数据对每个处理器都是唯一的，不需要自旋锁来保护，但是如果被抢占，一个新调度的任务就有可能访问同一个变量，造成不一致。
	  preempt_disable()用于禁用抢占，可以递归调用，preempt_enable()用于激活抢占，调用次数与preempt_disable()一致。
      j. 在执行读写操作时，编译器和处理器为了提高效率，可能对读和写指令进行重排，但是有时候在多处理器中或硬件设备间，对读写数据的顺序有要求，因此需要提供顺序屏障来确保执行顺序。rmb()提供了一个读屏障，确保跨越rmb()的载入动作不会发生重排序，wmb()提供了一个写屏障，确保跨越屏障的写操作不会发生重排序。
	  mb()同时提供读屏障和写屏障。前面的rmb()、wmb()和mb()是内存屏障，barrier()是编译器屏障，防止编译器跨屏障对载入和存储操作进行优化。内存屏障可以实现编译器屏障的功能。