栈 
在经典的操作系统里，栈总是向下增长的。栈顶由esp寄存器定位，栈底由ebp定位。压栈操作使栈顶的地址减小，弹出操作使栈顶地址增大。

当函数调用的时候发生了什么？
例如：
  1. int main(void)  
  2. {  
  3.     foo(1,2,3) ;  
  4.     return 0 ;  
  5. }  
当方法main需要调用foo时，它的标准行为：
1、在main方法的调用栈中，将 foo的参数从右向左 依次push到栈中。
2、把main方法当前指令的 下一条指令地址 （即return address）push到栈中。(隐藏在call指令中)
3、使用call指令调用目标函数体foo。

请注意，以上3步都处于main的调用栈，其中ebp保存其栈底，而esp保存其栈顶。
接下来，在foo函数中：
1、push ebp:                  将ebp的当前值push到栈中，即保存ebp。
2、mov ebp,esp:            将esp的值赋给ebp，则意味着进入了foo方法的调用栈。
3、[可选]sub esp, XXX: 在栈上分配XXX字节的临时空间。（抬高栈顶）(编译器根据函数中的局部变量的总大小确定临时空间的大小)
4、[可选]push XXX:        保存（push）一些寄存器的值。
【注意：push寄存器的值，这一操作，可以在分配临时空间之前，也可在其之后，《程序员的自我修养》写的是在开辟临时变量之后】
（编译器中保存的有相应的变量名对应的临时空间中的位置）

而在foo方法调用完毕后，便执行前面阶段的逆操作：
1、保存返回值:          通常将函数的返回值保存在寄存器eax中。
2、[可选]恢复（pop）一些寄存器的值。
3、mov esp,ebp:     恢复esp同时回收局部变量空间。（恢复原栈顶）
4、pop ebp:            恢复ebp，即恢复main调用栈的栈底。（恢复原栈底）
5、ret:                        从栈顶获得之前保留的return address，并跳转到此位置继续执行。

main方法先将foo方法所需的参数压入栈中，然后再改变ebp，进入foo方法的调用栈。
因此，如果在foo方法中需要访问那些参数，则需要根据当前ebp中的值，再向高地址偏移后进行访问——因为高地址才是main方法的调用栈。
也就是说，地址ebp + 8存放了foo方法的第1个参数，地址ebp + 12存放了foo方法的第2个参数，以此类推。那么地址ebp + 4存放了什么呢？它存放的是return address，即foo方法返回后，需要继续执行下去的main方法指令的地址。
【注意】
若需在函数中保存被调函数保存寄存器(如ESI、EDI)，则编译器在保存EBP值时进行保存，或延迟保存直到局部变量空间被分配。在栈帧中并未为被调函数保存寄存器的空间指定标准的存储位置。

【注：几个相关的寄存器（关于详细的介绍，见王爽汇编）】
(1)esp：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。
(2)ebp：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。（ebp在当前栈帧内位置固定，故函数中对大部分数据的访问都基于ebp进行）
(3)eip：指令寄存器(extended instruction pointer)，其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。 可以说如果控制了EIP寄存器的内容，就控制了进程——我们让eip指向哪里，CPU就会去执行哪里的指令。eip可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变)(ret指令就是把当前栈顶保存的返回值地址 弹到eip中)

函数栈帧的大小并不固定，一般与其对应函数的局部变量多少有关。函数运行过程中，其栈帧大小也是在不停变化的。

函数返回值传递
一般情况下，寄存器eax是传递返回值的通道，函数将返回值存储在eax中，返回后函数的调用方再读取eax。
但是eax本身只有4字节，那么大于4字节的返回值是如何传递的呢？
对于返回5~8字节数据的情况，一般采用eax和edx联合返回的方式进行的。其中eax存储返回值的低4字节，edx存储返回值的高4字节。

对于超过8字节的返回类型：
  1. typedef struct big_thing  
  2. {  
  3.     char buf[128] ;  
  4. } big_thing ;  
  5.   
  6. big_thing return_test();  
  7.   
  8. //---------------------------  
  9. int main(void)  
  10. {  
  11.     big_thing n = return_test() ;  
  12. }  
  13.   
  14. big_thing return_test()  
  15. {  
  16.     big_thing b ;  
  17.     b.buf[0] = 0 ;  
  18.     return b ;  
  19. }  
分析这段代码：
首先，在主调函数main中，肯定有一个128字节的变量n，在被调函数return_test中，肯定有一个128字节的变量b。
那被调函数如何返回128字节的变量？直接从b拷贝到n么？你这样直接改变主调函数中变量的值，似乎不符合返回值传值的规则。

那么实际上，编译器是怎么设计大尺寸返回值传递的呢？
* main函数在其栈中的局部变量区域中额外开辟一片空间，将其一部分作为传递返回值的临时对象temp。
* 将temp对象的地址作为隐藏参数传递给return_test函数。
* return_test函数将数据拷贝给temp对象，并将temp对象的地址用eax传出。
* return_test返回后，main函数将eax指向的temp对象的内容拷贝给n。


（return_test是没有真正的参数的，只有一个“伪参数”由函数的调用方悄悄传入）

【总结】
函数返回值的传递：小于8字节的返回值，以寄存器为中转。大于8字节的，以主调函数中新开辟的同样大小的中间变量temp为中转。
c语言对于尺寸太大的返回值类型，会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。故不到万不得已，不要轻易返回大尺寸对象。