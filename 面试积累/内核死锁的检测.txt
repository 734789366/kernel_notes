1. 内核软死锁（soft lockup）bug原因分析
Soft lockup名称解释：所谓，soft lockup就是说，这个bug没有让系统彻底死机，但是若干个进程（或者kernel thread）被锁死在了某个状态（一般在内核区域），很多情况下这个是由于内核锁的使用的问题。
Linux内核对于每一个cpu都有一个监控进程叫做watchdog（看门狗）。通过ps –ef | grep watchdog能够看见，进程名称大概是watchdog/X（数字：cpu逻辑编号1/2/3/4之类的）。这个进程或者线程每隔一段时间运行一次，进行喂狗操作，否则会睡眠和待机。
这个喂狗线程在运行时会收集每一个cpu运行时使用数据的时间并且存放到属于每个cpu自己的内核数据结构中。看门狗的hrtimer中断函数会调用soft lockup计数，并使用当前的时间戳与对应的cpu的内核数据结构中保存的时间对比，如果发现当前的时间戳比对应cpu保存的时间大于设定的阀值，他就假设监测进程或看门狗喂狗线程在一个相当可观的时间还没有执。
CPU软锁为什么会产生，是怎么产生的？如果linux内核是经过精心设计安排的CPU调度访问，那么怎么会产生cpu软死锁？那么只能说由于用户开发的或者第三方软件引入，看我们服务器内核panic的原因就是qmgr进程引起。因为每一个无限的循环都会一直有一个cpu的执行流程（qmgr进程示一个后台邮件的消息队列服务进程），并且拥有一定的优先级。
Cpu调度器调度一个驱动程序来运行，如果这个驱动程序有问题并且没有被检测到，那么这个驱动程序将会暂用cpu的很长时间。根据前面的描述，看门狗进程会抓住（catch）这一点并且抛出一个软死锁（soft lockup）错误。软死锁会挂起cpu使你的系统不可用。
如果是用户空间的进程或线程引起的问题backtrace是不会有内容的，如果内核线程那么在soft lockup消息中会显示出backtrace信息。

1.通过cpu_callback函数调用watchdog_enable，在每个CPU core上创建SCHED_FIFO级别的实时线程watchdog，其中使用了hrtimer定时器，控制检查周期。
2.hrtimer定时器调用watchdog_timer_fn进行清狗的时间检查，而线程则每次重置清狗时间。正常情况下，喂狗线程会在规定的时间之内被调度到，清狗时间能够得到及时重置，看门狗不会超时。而如果抢占被关闭很长时间，喂狗线程没有能得到及时调度，则看门狗就会超时，调用超时函数，如果watchdog_timer_fn发现狗的重置时间已经和当前时间差出危险值，则根据开关进行panic处理。

soft lockup是由于抢占被关闭了很长时间，没有其他进程能够运行造成的；
hard lockup是由于中断被关闭了很长时间，没有其他中断能够运行造成的；